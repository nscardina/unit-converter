{
  "version": 3,
  "sources": ["../../ts-fraction/src/gcd.ts", "../../ts-fraction/src/utils.ts", "../../ts-fraction/src/fraction.ts", "../../ts-fraction/src/expression/tokentype.ts", "../../ts-fraction/src/expression/expression.ts", "../../ts-fraction/src/index.ts"],
  "sourcesContent": ["/**\n * Finds the greatest common divisor of two `bigint`s, using the \n * {@link https://en.wikipedia.org/wiki/Binary_GCD_algorithm Binary GCD algorithm}.\n * @param u first `bigint`.\n * @param v second `bigint`.\n * @returns greatest common divisor of the two `bigint`s.\n */\nfunction gcd(u: bigint, v: bigint): bigint {\n\n    if (u < 0) u = -u\n    if (v < 0) v = -v\n\n    // Must multiply the gcd we find by this at the end.\n    let finalCoefficient: bigint = 1n\n    let uIsOdd;\n    let vIsOdd;\n\n    while (true) {\n\n        if (u === 0n) return v * finalCoefficient\n        if (v === 0n) return u * finalCoefficient\n\n        uIsOdd = (u % 2n) === 1n\n        vIsOdd = (v % 2n) === 1n\n\n        if (!uIsOdd) {\n            if (!vIsOdd) {\n                finalCoefficient *= 2n\n                u /= 2n\n                v /= 2n\n            } else {\n                u /= 2n\n            }\n        } else {\n            if (!vIsOdd) {\n                v /= 2n\n            } else {\n                let difference = u - v\n                if (difference < 0) difference = -difference\n                v = (u > v) ? v : u\n                u = difference\n            }\n        }\n    }\n}\n\nexport default gcd", "import Fraction from \"./fraction\"\n\n/**\n * Regex that represents the following pattern:\n * - zero or one `U+002D - HYPHEN MINUS` or `U+002B + PLUS SIGN` characters, followed by\n * - one or more digits (`0`-`9`).\n */\nconst INTEGER_STRING_REGEX: RegExp = /^[-\\+]?\\d+$/\n\n/**\n * Regex that represents the following patterN:\n * - zero or one `U+002D - HYPHEN MINUS`) or `U+002B + PLUS SIGN` characters, followed by\n * - zero or more digits (`0`-`9`), possibly followed by \n * - one `U+002E . FULL STOP` character and one or more digits (`0`-`9`).\n */\n// export const DECIMAL_STRING_REGEX: RegExp = /^[-\\+]?\\d*(.\\d+)?$/\nexport const DECIMAL_STRING_REGEX: RegExp = \n/^[-\\+]?((\\d*)(?=(\\.\\d+))|(\\d+)(?!(\\.\\d+)))((\\.\\d+)(?<!([-\\+]?\\d+))|((\\.\\d+)?)(?<=([-\\+]?\\d+)))$/\n\nexport const DECIMAL_STRING_REGEX_BEGINNING = \n/^[-\\+]?((\\d*)(?=(\\.\\d+))|(\\d+)(?!(\\.\\d+)))((\\.\\d+)(?<!([-\\+]?\\d+))|((\\.\\d+)?)(?<=([-\\+]?\\d+)))/\n\nexport const DECIMAL_STRING_REGEX_NO_BEGINNING_OR_END = \n/.*[-\\+]?((\\d*)(?=(\\.\\d+))|(\\d+)(?!(\\.\\d+)))((\\.\\d+)(?<!([-\\+]?\\d+))|((\\.\\d+)?)(?<=([-\\+]?\\d+))).*/\n\n/**\n * Determines whether a particular string `str` can be converted to a `bigint`. That is, this method \n * checks if `str` matches the {@linkcode INTEGER_STRING_REGEX} pattern.\n * @param str string to test.\n * @returns whether the string can be converted to a `bigint`.\n */\nexport function canBeConvertedToBigInt(str: string) {\n    return INTEGER_STRING_REGEX.test(str)\n}\n\n/**\n * Determines if a string is a decimal string; that is, if it matches the {@linkcode DECIMAL_STRING_REGEX} \n * pattern and thus represents a decimal number.\n * @param str string to test.\n * @returns whether the string represents a decimal number.\n */\nexport function isDecimalString(str: string) {\n    return INTEGER_STRING_REGEX.test(str)\n}\n\n/**\n * Determines whether a particular string `str` can be converted to a {@linkcode Fraction}. Currently, this \n * method only checks whether a string which conforms to the {@linkcode DECIMAL_STRING_REGEX} pattern, as such \n * a string can always be converted to a `Fraction` via the {@linkcode Fraction.parseString Fraction.parseString()} \n * static method.\n * @param str string to test.\n * @returns whether the string can be converted to a `Fraction`.\n */\nexport function canBeConvertedToFraction(str: string) {\n    return DECIMAL_STRING_REGEX.test(str)\n}", "\"use strict\";\n\nimport { parseExpression } from \"./expression/expression\";\nimport gcd from \"./gcd\";\nimport { canBeConvertedToBigInt, canBeConvertedToFraction, isDecimalString } from \"./utils\";\n\n/**\n * The `Fraction` class represents a mathematical fraction. Like a mathematical fraction, it contains `numerator` and \n * `denominator` fields, and supports various mathematical operations. However, the `numerator` and `denominator` of \n * a `Fraction` object can only contain `bigint` values; they cannot themselves be fractions, decimals, or anything but \n * integers.\n * \n * ## Creating `Fraction`s\n * `Fraction` objects can be created using the {@linkcode parseString()} static method, or using the constructor.\n * \n * ## Supported Operations\n * `Fraction` objects support the following operations:\n * - **addition**, using the {@linkcode plus()} method,\n * - **subtraction**, using the {@linkcode minus()} method,\n * - **multiplication**, using the {@linkcode times()} method,\n * - **division**, using the {@linkcode div()} method.\n * \n * `Fraction` objects also have the other following methods:\n * - {@linkcode equals()}, for testing for equality with other numbers and fractions\n */\nclass Fraction {\n\n    /**\n     * Parses a `string`, converting it into a `Fraction` object. If the string `str` passed to this method is \n     * valid (i.e. {@linkcode canBeConvertedToFraction()} returns `true` when `str` is passed to it), then the \n     * resulting fraction will satisfy the following characteristics:\n     * - If `str` represents a decimal number (i.e. {@linkcode isDecimalString()} returns `true` when `str` is \n     * passed to it), then the `bigint` value of `str` when its decimal point is removed will become the \n     * {@linkcode numerator} of the resulting `Fraction`. If the number of digits to the right of the decimal \n     * point in `str` is *n*, then the {@linkcode denominator} of the resulting `Fraction` is the `bigint` \n     * value `10^n`.\n     * @param str string to convert to a `Fraction`.\n     * @returns newly created `Fraction` object.\n     * @throws if the string cannot be converted successfully.\n     */\n    static parseString(str: string): Fraction {\n        if (!canBeConvertedToFraction(str)) {\n            throw new Error('Invalid string: Cannot be converted to Fraction')\n        }\n\n        const decimalPointIndex = str.indexOf('.')\n        if (decimalPointIndex === -1) {\n            return new Fraction(str, 1n)\n        }\n\n        const digitsRightOfPoint = str.substring(decimalPointIndex + 1)\n        const numDigitsRightOfPoint = BigInt(digitsRightOfPoint.length)\n\n        return new Fraction(BigInt(str.replace('.', '')), BigInt((10n ** (numDigitsRightOfPoint))))\n    }\n\n\n    /**\n     * Numerator of this `Fraction`.\n     */\n    numerator: bigint\n\n    /**\n     * Denominator of this `Fraction`.\n     */\n    denominator: bigint\n\n    /**\n     * Constructs a new `Fraction` object.\n     * This method can construct `Fraction` objects from either of the following sets of arguments: \n     * - `a`: `Fraction` (clones the {@linkcode numerator} and {@linkcode denominator} of `a`)\n     * - `a`: `number | bigint | string`, `b`: `number | bigint | string` (sets the `numerator` to \n     * the `bigint` value of `a` and the `denominator` to the `bigint` value of `b`, both obtained \n     * through calling the \n     * {@linkcode https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt/BigInt BigInt()}\n     * function)\n     * - No parameters, in which case `0n` is used as both the `numerator` and `denominator` of the \n     * newly constructed `Fraction` object.\n     * @param {Fraction | number | bigint | string | undefined} a first parameter.\n     * @param {number | bigint | string | undefined} b second parameter.\n     * @throws TypeError if the parameters are not of the types specified above.\n     */\n    constructor(\n        a?: Fraction | number | bigint | string, \n        b?: number | bigint | string\n    ) {\n        \n        if (a instanceof Fraction) {\n            this.numerator = a.numerator\n            this.denominator = a.denominator\n        } else if (\n            ((typeof(a) === 'bigint') \n                || (typeof(a) === 'number' && Number.isInteger(a))\n                || (typeof(a) === 'string' && canBeConvertedToBigInt(a))) &&\n            ((typeof(b) === 'bigint')\n                || (typeof(b) === 'number' && Number.isInteger(b))\n                || (typeof(b) === 'string' && canBeConvertedToBigInt(b)))\n        ) {\n            this.numerator = BigInt(a)\n            this.denominator = BigInt(b)\n        } else if (a === undefined && b === undefined) {\n            this.numerator = 0n\n            this.denominator = 1n\n        } else {\n            const paramACorrect = ((typeof(a) === 'bigint') \n            || (typeof(a) === 'number' && Number.isInteger(a))\n            || (typeof(a) === 'string' && canBeConvertedToBigInt(a)))\n            const paramBCorrect = ((typeof(b) === 'bigint')\n            || (typeof(b) === 'number' && Number.isInteger(b))\n            || (typeof(b) === 'string' && canBeConvertedToBigInt(b)))\n            throw new TypeError(`Invalid parameters \"${\n                !paramACorrect ? (a as any) : ''\n            }\"${!paramBCorrect ? `, \"${(b as any)}\"` : ''\n            }: Must be of type \"number (integral) | bigint | string, or one Fraction parameter\"`)\n        }\n\n        this.simplify()\n    }\n\n    /**\n     * Adds a number of some type to this `Fraction`. The number may be expressed either as a single \n     * `number`, `bigint`, or `string` passed as the first parameter, two arguments each of type \n     * `number`, `bigint`, or `string`, or as one single `Fraction` parameter.\n     * @param {Fraction | number | bigint | string} a first parameter.\n     * @param {number | bigint | string | undefined} b second parameter.\n     * @throws TypeError if the parameters are not of the type specified above.\n     */\n    plus(\n        a: Fraction | number | bigint | string,\n        b?: number | bigint | string\n    ): Fraction {\n        if (a instanceof Fraction) {\n            b = a.denominator\n            a = a.numerator\n        }\n\n        if (\n            ((typeof(a) === 'bigint') \n                || (typeof(a) === 'number' && Number.isInteger(a))\n                || (typeof(a) === 'string' && canBeConvertedToBigInt(a))) &&\n            ((typeof(b) === 'bigint')\n                || (typeof(b) === 'number' && Number.isInteger(b))\n                || (typeof(b) === 'string' && canBeConvertedToBigInt(b))\n                || b === undefined)\n        ) {\n            a = BigInt(a)\n            if (b !== undefined) {\n                b = BigInt(b)\n            } else  {\n                b = 1n\n            } \n            \n            let newNumerator = this.numerator * b + a * this.denominator\n            let newDenominator = this.denominator * b\n            let commonFactor = gcd(newNumerator, newDenominator)\n            return new Fraction(newNumerator / commonFactor, newDenominator / commonFactor).simplify()\n        } else {\n            const paramACorrect = ((typeof(a) === 'bigint') \n            || (typeof(a) === 'number' && Number.isInteger(a))\n            || (typeof(a) === 'string' && canBeConvertedToBigInt(a)))\n            const paramBCorrect = ((typeof(b) === 'bigint')\n            || (typeof(b) === 'number' && Number.isInteger(b))\n            || (typeof(b) === 'string' && canBeConvertedToBigInt(b))\n            || b === undefined)\n            throw new TypeError(`Invalid parameters \"${\n                !paramACorrect ? (a as any) : ''\n            }\"${!paramBCorrect ? `, \"${(b as any)}\"` : ''\n            }: Must be of type \"number | bigint | string, or one Fraction parameter\"`)\n        }\n        \n        \n    }\n\n    /**\n     * Subtracts a number of some type from this `Fraction`. The number may be expressed either as a single \n     * `number`, `bigint`, or `string` passed as the first parameter, two arguments each of type \n     * `number`, `bigint`, or `string`, or as one single `Fraction` parameter.\n     * @param {Fraction | number | bigint | string} a first parameter.\n     * @param {number | bigint | string | undefined} b second parameter.\n     * @throws TypeError if the parameters are not of the type specified above.\n     */\n    minus(\n        a: Fraction | number | bigint | string,\n        b?: number | bigint | string\n    ): Fraction {\n        if (a instanceof Fraction) {\n            b = a.denominator\n            a = a.numerator\n        }\n\n        if (\n            ((typeof(a) === 'bigint') \n                || (typeof(a) === 'number' && Number.isInteger(a))\n                || (typeof(a) === 'string' && canBeConvertedToBigInt(a))) &&\n            ((typeof(b) === 'bigint')\n                || (typeof(b) === 'number' && Number.isInteger(b))\n                || (typeof(b) === 'string' && canBeConvertedToBigInt(b))\n                || b === undefined)\n        ) {\n            a = BigInt(a)\n            if (b !== undefined) {\n                b = BigInt(b)\n            } else  {\n                b = 1n\n            } \n            \n            let newNumerator = this.numerator * b - a * this.denominator\n            let newDenominator = this.denominator * b\n            let commonFactor = gcd(newNumerator, newDenominator)\n            return new Fraction(newNumerator / commonFactor, newDenominator / commonFactor).simplify()\n        } else {\n            const paramACorrect = ((typeof(a) === 'bigint') \n            || (typeof(a) === 'number' && Number.isInteger(a))\n            || (typeof(a) === 'string' && canBeConvertedToBigInt(a)))\n            const paramBCorrect = ((typeof(b) === 'bigint')\n            || (typeof(b) === 'number' && Number.isInteger(b))\n            || (typeof(b) === 'string' && canBeConvertedToBigInt(b))\n            || b === undefined)\n            throw new TypeError(`Invalid parameters \"${\n                !paramACorrect ? (a as any) : ''\n            }\"${!paramBCorrect ? `, \"${(b as any)}\"` : ''\n            }: Must be of type \"number | bigint | string, or one Fraction parameter\"`)\n        }\n        \n    }\n\n    /**\n     * Multiplies this `Fraction` by a number of some type. The number may be expressed either as a single \n     * `number`, `bigint`, or `string` passed as the first parameter, two arguments each of type \n     * `number`, `bigint`, or `string`, or as one single `Fraction` parameter.\n     * @param {Fraction | number | bigint | string} a first parameter.\n     * @param {number | bigint | string | undefined} b second parameter.\n     * @throws TypeError if the parameters are not of the type specified above.\n     */\n    times(\n        a: Fraction | number | bigint | string,\n        b?: number | bigint | string\n    ): Fraction {\n        if (a instanceof Fraction) {\n            b = a.denominator\n            a = a.numerator\n        }\n\n        if (\n            ((typeof(a) === 'bigint') \n                || (typeof(a) === 'number' && Number.isInteger(a))\n                || (typeof(a) === 'string' && canBeConvertedToBigInt(a))) &&\n            ((typeof(b) === 'bigint')\n                || (typeof(b) === 'number' && Number.isInteger(b))\n                || (typeof(b) === 'string' && canBeConvertedToBigInt(b))\n                || b === undefined)\n        ) {\n            a = BigInt(a)\n            if (b !== undefined) {\n                b = BigInt(b)\n            } else  {\n                b = 1n\n            } \n            \n            let newNumerator = this.numerator * a \n            let newDenominator = this.denominator * b\n            let commonFactor = gcd(newNumerator, newDenominator)\n            return new Fraction(newNumerator / commonFactor, newDenominator / commonFactor).simplify()\n        } else {\n            const paramACorrect = ((typeof(a) === 'bigint') \n            || (typeof(a) === 'number' && Number.isInteger(a))\n            || (typeof(a) === 'string' && canBeConvertedToBigInt(a)))\n            const paramBCorrect = ((typeof(b) === 'bigint')\n            || (typeof(b) === 'number' && Number.isInteger(b))\n            || (typeof(b) === 'string' && canBeConvertedToBigInt(b))\n            || b === undefined)\n            throw new TypeError(`Invalid parameters \"${\n                !paramACorrect ? (a as any) : ''\n            }\"${!paramBCorrect ? `, \"${(b as any)}\"` : ''\n            }: Must be of type \"number | bigint | string, or one Fraction parameter\"`)\n        }\n        \n    }\n\n    /**\n     * Divides this `Fraction` by a number of some type. The number may be expressed either as a single \n     * `number`, `bigint`, or `string` passed as the first parameter, two arguments each of type \n     * `number`, `bigint`, or `string`, or as one single `Fraction` parameter.\n     * @param {Fraction | number | bigint | string} a first parameter.\n     * @param {number | bigint | string | undefined} b second parameter.\n     * @throws TypeError if the parameters are not of the type specified above.\n     */\n    div(\n        a: Fraction | number | bigint | string,\n        b?: number | bigint | string\n    ): Fraction {\n        if (a instanceof Fraction) {\n            b = a.denominator\n            a = a.numerator\n        }\n\n        if (\n            ((typeof(a) === 'bigint') \n                || (typeof(a) === 'number' && Number.isInteger(a))\n                || (typeof(a) === 'string' && canBeConvertedToBigInt(a))) &&\n            ((typeof(b) === 'bigint')\n                || (typeof(b) === 'number' && Number.isInteger(b))\n                || (typeof(b) === 'string' && canBeConvertedToBigInt(b))\n                || b === undefined)\n        ) {\n            a = BigInt(a)\n            if (b !== undefined) {\n                b = BigInt(b)\n            } else  {\n                b = 1n\n            } \n            \n            let newNumerator = this.numerator * b \n            let newDenominator = this.denominator * a\n            let commonFactor = gcd(newNumerator, newDenominator)\n            return new Fraction(newNumerator / commonFactor, newDenominator / commonFactor).simplify()\n        } else {\n            const paramACorrect = ((typeof(a) === 'bigint') \n            || (typeof(a) === 'number' && Number.isInteger(a))\n            || (typeof(a) === 'string' && canBeConvertedToBigInt(a)))\n            const paramBCorrect = ((typeof(b) === 'bigint')\n            || (typeof(b) === 'number' && Number.isInteger(b))\n            || (typeof(b) === 'string' && canBeConvertedToBigInt(b))\n            || b === undefined)\n            throw new TypeError(`Invalid parameters \"${\n                !paramACorrect ? (a as any) : ''\n            }\"${!paramBCorrect ? `, \"${(b as any)}\"` : ''\n            }: Must be of type \"number | bigint | string, or one Fraction parameter\"`)\n        }\n        \n    }\n\n    /**\n     * Tests this `Fraction` for equality with a number of some type. The number may be expressed either as a single \n     * `number`, `bigint`, or `string` passed as the first parameter, two arguments each of type \n     * `number`, `bigint`, or `string`, or as one single `Fraction` parameter.\n     * @param {Fraction | number | bigint | string} a first parameter.\n     * @param {number | bigint | string | undefined} b second parameter.\n     * @throws TypeError if the parameters are not of the type specified above.\n     */\n    equals(\n        a: Fraction | number | bigint | string,\n        b?: number | bigint | string\n    ): boolean {\n        if (a instanceof Fraction) {\n            b = a.denominator\n            a = a.numerator\n        }\n\n        if (\n            ((typeof(a) === 'bigint') \n                || (typeof(a) === 'number' && Number.isInteger(a))\n                || (typeof(a) === 'string' && canBeConvertedToBigInt(a))) &&\n            ((typeof(b) === 'bigint')\n                || (typeof(b) === 'number' && Number.isInteger(b))\n                || (typeof(b) === 'string' && canBeConvertedToBigInt(b))\n                || b === undefined)\n        ) {\n            a = BigInt(a)\n            if (b !== undefined) {\n                b = BigInt(b)\n            } else  {\n                b = 1n\n            } \n\n            return this.numerator === a && this.denominator === b\n        } else {\n            const paramACorrect = ((typeof(a) === 'bigint') \n            || (typeof(a) === 'number' && Number.isInteger(a))\n            || (typeof(a) === 'string' && canBeConvertedToBigInt(a)))\n            const paramBCorrect = ((typeof(b) === 'bigint')\n            || (typeof(b) === 'number' && Number.isInteger(b))\n            || (typeof(b) === 'string' && canBeConvertedToBigInt(b))\n            || b === undefined)\n            throw new TypeError(`Invalid parameters \"${\n                !paramACorrect ? (a as any) : ''\n            }\"${!paramBCorrect ? `, \"${(b as any)}\"` : ''\n            }: Must be of type \"number | bigint | string, or one Fraction parameter\"`)\n        }\n        \n    }\n\n    /**\n     * Simplifies this `Fraction` by dividing by the common factor of the `numerator` and `denominator`.\n     */\n    simplify(): Fraction {\n        const commonFactor = gcd(this.numerator, this.denominator)\n        this.numerator /= commonFactor\n        this.denominator /= commonFactor\n        return this\n    }\n\n    /**\n     * Returns a decimal `string` representation of this `Fraction`, accurate to a certain number of \n     * decimal places.\n     * @param numDecimalPlaces number of decimal places of accuracy to generate for the fraction's \n     * decimal representation.\n     * @returns decimal representation of this `Fraction`.\n     */\n    toDecimal(numDecimalPlaces: bigint) {\n\n        let strNumerator = this.numerator.toString()\n        let strDenominator = this.denominator.toString()\n\n        let absNum: bigint = 0n\n        let absDen: bigint = 0n\n\n        const negative = strNumerator.startsWith('-') !== strDenominator.startsWith('-')\n        if (strNumerator.startsWith('-')) {\n            strNumerator = strNumerator.substring(1)\n            absNum = -this.numerator\n        } else {\n            absNum = this.numerator\n        }\n        if (strDenominator.startsWith('-')) {\n            strDenominator = strDenominator.substring(1)\n            absDen = -this.denominator\n        } else {\n            absDen = this.denominator\n        }\n\n        let decimal = \"\"\n        let dividend: bigint\n        let quotient: bigint = 0n\n        let remainder: bigint = 0n\n\n        // Write out the non-decimal part first\n        for (let i = 0; i < strNumerator.length; i++) {\n            dividend = remainder * 10n + BigInt(strNumerator.substring(i, i + 1))\n            quotient = dividend / absDen\n            remainder = dividend % absDen\n\n            decimal += quotient\n        }\n\n        if (numDecimalPlaces > 0n) {\n            decimal += '.'\n\n            for (let i = 0; i < numDecimalPlaces + 1n; i++) {\n\n                dividend = remainder * 10n\n                quotient = dividend / absDen\n                remainder = dividend % absDen\n    \n                decimal += quotient\n            }\n\n            if (BigInt(decimal.substring(decimal.length - 1, decimal.length)) >= 5n) {\n                decimal = decimal.substring(0, decimal.length - 2) + (BigInt(decimal[decimal.length - 2]) + 1n).toString()\n            } else {\n                decimal = decimal.substring(0, decimal.length - 1)\n            }\n        }\n\n        // return decimal after removing any zeroes in front of the decimal place.\n        decimal = decimal.replace(/^0*(?!\\.)/, '')\n        if (/\\.0+$/.test(decimal)) {\n            decimal = decimal.replace(/\\.0+$/, '')\n        }\n        if (negative) {\n            decimal = `-${decimal}`\n        }\n        return decimal\n    }\n\n}\n\nexport default Fraction", "import { DECIMAL_STRING_REGEX_BEGINNING } from \"../utils\"\n\n/**\n * Type representing one single {@linkcode TokenType}, and holds all relevant data. \n * This data is, currently, a {@linkcode RegExp} used for determining whether the \n * beginning of a `string` matches this type of token.\n */\ntype TokenTypeInstance = Readonly<{\n    startingRegex: RegExp\n}>\n\n/**\n * Object holding several different `TokenTypeInstances`:\n * - `AdditionOperator`, which matches `+ U+002B PLUS SIGN`;\n * - `SubtractionOperator`, which matches `- U+002D HYPHEN-MINUS`;\n * - `MultiplicationOperator`, which matches `* U+002A ASTERISK`;\n * - `DivisionOperator`, which matches `/ U+002F SOLIDUS`;\n * - `LeftParenthesisOperator`, which matches `( U+0028 LEFT PARENTHESIS`;\n * - `RightParenthesisOperator`, which matches `) U+0029 RIGHT PARENTHESIS`;\n * - `Number`, which matches {@linkcode DECIMAL_STRING_REGEX_BEGINNING}.\n */\nconst TokenType: {\n    AdditionOperator: TokenTypeInstance,\n    SubtractionOperator: TokenTypeInstance,\n    MultiplicationOperator: TokenTypeInstance,\n    DivisionOperator: TokenTypeInstance, \n    LeftParenthesisOperator: TokenTypeInstance,\n    RightParenthesisOperator: TokenTypeInstance,\n    Number: TokenTypeInstance\n} = Object.freeze({\n    AdditionOperator: Object.freeze({\n        startingRegex: /^\\+/\n    }),\n    SubtractionOperator: Object.freeze({\n        startingRegex: /^-/\n    }),\n    MultiplicationOperator: Object.freeze({\n        startingRegex: /^\\*/\n    }),\n    DivisionOperator: Object.freeze({\n        startingRegex: /^\\//\n    }),\n    LeftParenthesisOperator: Object.freeze({\n        startingRegex: /^\\(/\n    }),\n    RightParenthesisOperator: Object.freeze({\n        startingRegex: /^\\)/\n    }),\n    Number: Object.freeze({\n        startingRegex: DECIMAL_STRING_REGEX_BEGINNING\n    })\n})\n\nexport type { TokenTypeInstance }\nexport default TokenType", "import TokenType from \"./tokentype\"\nimport Fraction from \"../fraction\"\n\nimport type { TokenTypeInstance } from \"./tokentype\"\n\n/**\n * Returns an array containing\n * - in index `0`, a {@linkcode TokenTypeInstance}, \n * - in index `1`, the `string` at the beginning of the `str` parameter which matches the \n * `TokenTypeInstance`'s {@linkcode TokenTypeInstance.startingRegex startingRegex}, and \n * - if the `TokenTypeInstance` is {@linkcode TokenType.Number}, in index `2`, this method \n * returns the {@linkcode Fraction} which is created by parsing the `str` parameter.\n * @param str string to process.\n * @returns array, as described above, or `null` if no valid token is found.\n * @throws {@linkcode InvalidTokenError} if the {@linkcode Fraction.parseString()} method throws.\n */\nfunction matchTokenAtBeginningOfString(str: string): [TokenTypeInstance, string, Fraction?] | null {\n\n    for (const token of Object.values(TokenType)) {\n        if (token.startingRegex.test(str)) {\n\n            // Token matches the beginning of the string\n            if (token === TokenType.Number) {\n\n                // We know this will always succeed because we know the token's startingRegex \n                // matches the beginning of the string, but TypeScript doesn't know that so \n                // include !. Also return only the first match - there should be only one match, \n                // given that the startingRegex tests only for values at the beginning of the \n                // string.\n                const matchedStringArray = str.match(token.startingRegex)!\n                try {\n                    return [token, str.replace(token.startingRegex, ''),\n                        Fraction.parseString(matchedStringArray[0])]\n                } catch (err) {\n                    if (err instanceof Error && err.message === 'Invalid string: Cannot be converted to Fraction') {\n                        throw new InvalidTokenError(`Invalid number ${matchedStringArray[0]} cannot be converted to Fraction`)\n                    }\n                }\n            }\n\n            return [token, str.replace(token.startingRegex, '')]\n        }\n    }\n\n    // No tokens match the beginning of the string.\n    return null\n}\n\n/**\n * Parses a `string` into an array of objects, which represent the operators and \n * terms of an expression. These objects will either be {@linkcode TokenTypeInstance}\n * objects or {@linkcode Fraction} objects. If any invalid tokens are encountered, \n * a {@linkcode InvalidTokenError} will be thrown.\n * @param str `string` to parse.\n * @returns array of objects representing the terms and operators in `str`.\n * @throws `InvalidTokenError` if characters which do not match any known token type \n * are found in the the `str` argument.\n */\nfunction parseToTokens(str: string): (TokenTypeInstance | Fraction)[] {\n\n    let tokens: (TokenTypeInstance | Fraction)[] = []\n\n    str = removeAllWhitespace(str)\n\n    while (str.length > 0) {\n        const token = matchTokenAtBeginningOfString(str)\n        if (token !== null) {\n            if (token[2] !== undefined) {\n                tokens.push(token[2])\n            } else {\n                tokens.push(token[0])\n            }\n            str = token[1]\n        } else {\n            throw new InvalidTokenError(`Invalid token at: ${str}`)\n        }\n    }\n\n    return tokens\n}\n\n/**\n * Removes all whitespace characters from a string `str` (that is, any characters that are \n * matched by the `\\s` regex character class. See \n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Character_classes this MDN page}\n * for details.)\n * @param str string to remove whitespace from.\n * @returns string, after any whitespace is removed.\n */\nfunction removeAllWhitespace(str: string) {\n    return str.replace(/\\s*/g, '')\n}\n\n/**\n * Finds the first pair of matching parentheses in an array of either {@linkcode TokenTypeInstance} or \n * {@linkcode Fraction} objects, and returns the indices of those parentheses in an array with two \n * elements. In other words, this method finds the first occurrence of `( U+0028 LEFT PARENTHESIS` which \n * has a `) U+0029 RIGHT PARENTHESIS` character after it with no other occurrences of `(` between that \n * left and right parenthesis. There can be any number of other characters between the left and right \n * parentheses, though. If no parentheses of either type are found, `null` is returned. If an unmatched \n * parenthesis is found, an {@linkcode UnmatchedParenthesisError} is throws indicating which parenthesis \n * is present in the string and is unmatched.\n * @param expr array of `TokenTypeInstance`s and `Fraction`s to parse.\n * @returns array of the form `[<index of left parenthesis>, <index of right parenthesis>]`\n * @throws `UnmatchedParenthesisError` if an unequal number of left and right parentheses are present \n * in the string.\n */\nfunction findFirstMatchingParentheses(expr: (TokenTypeInstance | Fraction)[]): [number, number] | null {\n    let leftIndex = -1;\n\n    for (let i = 0; i < expr.length; i++) {\n\n        if (expr[i] === TokenType.LeftParenthesisOperator) {\n            leftIndex = i\n        } else if (expr[i] === TokenType.RightParenthesisOperator) {\n            if (leftIndex === -1) {\n                throw new UnmatchedParenthesisError('Unmatched )')\n            }\n            return [leftIndex, i]\n        }\n    }\n\n    if (leftIndex !== -1) {\n        throw new UnmatchedParenthesisError('Unmatched (')\n    }\n\n    return null\n}\n\n/**\n * Parses an expression contained within an array of either {@linkcode Fraction} or \n * {@linkcode TokenTypeInstance} objects, assuming that this array contains no \n * parentheses (that is, it does not contain {@linkcode TokenType.LeftParenthesisOperator} \n * or {@linkcode TokenType.RightParenthesisOperator}). The expression will be evaluated \n * by the normal arithmetic order of operators, such that any multiplication and division \n * operations are evaluated first, from left to right, and then addition and subtraction \n * operations are evaluated from left to right. The result is then returned.\n * @param expr expression to parse.\n * @returns result of the calculation.\n * @throws `EvaluationError` if an operator does not have either of its operands as required.\n */\nfunction parseExprNoParens(expr: (Fraction | TokenTypeInstance)[]) {\n    // Solve multiplication/division\n    while (expr.includes(TokenType.MultiplicationOperator) || expr.includes(TokenType.DivisionOperator)) {\n        const index = expr.findIndex(\n            elem => elem === TokenType.MultiplicationOperator || elem === TokenType.DivisionOperator)\n\n        if (index - 1 < 0) {\n            throw new EvaluationError(`${\n                expr[index] === TokenType.MultiplicationOperator ? 'Multiplication' : 'Division'\n            } operator at index ${index} has no left operand`)\n        }\n\n        if (index + 1 >= expr.length) {\n            throw new EvaluationError(`${\n                expr[index] === TokenType.MultiplicationOperator ? 'Multiplication' : 'Division'\n            } operator at index ${index} has no right operand`)\n        }\n\n        if (expr[index - 1] instanceof Fraction && expr[index + 1] instanceof Fraction) {\n            expr[index - 1] = expr[index - 1]\n            if (expr[index] === TokenType.MultiplicationOperator) {\n                expr.splice(index - 1, 3, (expr[index - 1] as Fraction).times(expr[index + 1] as Fraction))\n            } else {\n                expr.splice(index - 1, 3, (expr[index - 1] as Fraction).div(expr[index + 1] as Fraction))\n            }\n        } else {\n            throw new EvaluationError(`${\n                !(expr[index - 1] instanceof Fraction) ? `${\n                    (expr[index] === TokenType.MultiplicationOperator) ? `Multiplication` : `Division`\n                } operator at index ${index - 1}` : ''\n            } ${\n                !(expr[index - 1] instanceof Fraction) && !(expr[index + 1] instanceof Fraction) ? `and ` : ''\n            }${\n                !(expr[index + 1] instanceof Fraction) ? `${\n                    (expr[index] === TokenType.MultiplicationOperator) ? `Multiplication` : `Division`\n                } operator at index ${index + 1} ` : ''\n            }has no ${\n                !(expr[index - 1] instanceof Fraction) ? 'left' : ''\n            } ${\n                !(expr[index - 1] instanceof Fraction) && !(expr[index + 1] instanceof Fraction) ? `or ` : ''\n            }${\n                !(expr[index + 1] instanceof Fraction) ? 'right ' : ''\n            }operand`)\n        }\n    }\n\n    // Solve addition/subtraction\n    while (expr.includes(TokenType.AdditionOperator) || expr.includes(TokenType.SubtractionOperator)) {\n        const index = expr.findIndex(\n            elem => elem === TokenType.AdditionOperator || elem === TokenType.SubtractionOperator)\n\n        if (index - 1 < 0) {\n            throw new EvaluationError(`${\n                expr[index] === TokenType.AdditionOperator ? 'Addition' : 'Subtraction'\n            } operator at index ${index} has no left operand`)\n        }\n\n        if (index + 1 >= expr.length) {\n            throw new EvaluationError(`${\n                expr[index] === TokenType.AdditionOperator ? 'Addition' : 'Subtraction'\n            } operator at index ${index} has no right operand`)\n        }\n\n        if (expr[index - 1] instanceof Fraction && expr[index + 1] instanceof Fraction) {\n            expr[index - 1] = expr[index - 1]\n            if (expr[index] === TokenType.AdditionOperator) {\n                expr.splice(index - 1, 3, (expr[index - 1] as Fraction).plus(expr[index + 1] as Fraction))\n            } else {\n                expr.splice(index - 1, 3, (expr[index - 1] as Fraction).minus(expr[index + 1] as Fraction))\n            }\n        } else {\n            throw new EvaluationError(`${\n                !(expr[index - 1] instanceof Fraction) ? `${\n                    (expr[index] === TokenType.AdditionOperator) ? `Addition` : `Subtraction`\n                } operator at index ${index - 1}` : ''\n            } ${\n                !(expr[index - 1] instanceof Fraction) && !(expr[index + 1] instanceof Fraction) ? `and ` : ''\n            }${\n                !(expr[index + 1] instanceof Fraction) ? `${\n                    (expr[index] === TokenType.AdditionOperator) ? `Addition` : `Subtraction`\n                } operator at index ${index + 1} ` : ''\n            }has no ${\n                !(expr[index - 1] instanceof Fraction) ? 'left' : ''\n            } ${\n                !(expr[index - 1] instanceof Fraction) && !(expr[index + 1] instanceof Fraction) ? `or ` : ''\n            }${\n                !(expr[index + 1] instanceof Fraction) ? 'right ' : ''\n            }operand`)\n        }\n    }\n\n    return expr\n}\n\n/**\n * Parses an arithmetic expression passed as a `string`, calculating the result as a `Fraction`.\n * \n * ## Valid characters in expressions\n * \n * Expressions can be made up of the following characters:\n * \n * - Digits `0`-`9`\n * - Arithmetic operators `+`, `-`, `*`, and `/`\n * - Left and right parentheses `(` and `)`\n * - Whitespace (any character matched by the `\\s` `RegExp` character class escape; see \n * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Character_class_escape#s this MDN page} \n * for more information)\n * \n * ## How expressions are evaluated\n * \n * Expressions are evaluated according to the {@link https://en.wikipedia.org/wiki/Order_of_operations order of operations}; \n * that is, the evaluation order is\n * \n * 1. expressions inside parentheses\n * 1. multiplication and division\n * 1. addition and subtraction\n * \n * Note that exponentiation and other functions are currently not supported.\n * \n * ## Possible errors\n * \n * Invalid expressions can cause this method to throw multiple exceptions, as detailed below:\n * - If any characters are included which are not listed above, {@linkcode InvalidTokenError} will \n * be thrown.\n * - If any numbers are included which cannot successfully be parsed into {@linkcode Fraction} objects \n * via the {@linkcode Fraction.parseString()} method, {@linkcode InvalidTokenError} will be thrown.\n * - If the expression contains unmatched parentheses, {@linkcode UnmatchedParenthesisError} will be \n * thrown.\n * - If the final result of the calculation does not end up being a `Fraction` object somehow, \n * {@linkcode InvalidTokenError} will be thrown.\n * - If any operator does not have both of its required operands, {@linkcode EvaluationError} will be \n * thrown.\n * - If the expression does not have at least one term, an {@linkcode Error} will be thrown.\n * @param expr expression to parse.\n * @returns result of evaluating the expression, as a {@linkcode Fraction}.\n */\nfunction parseExpression(expr: string): Fraction {\n    // Step 1: Parse expr into an array of tokens. Each number should be a token, and \n    // each operator should be a token.\n    let tokens = parseToTokens(expr)\n\n    while (tokens.length >= 1) {\n        // Step 2: Find the next expression in a set of parentheses to parse, if one exists.\n        const matchingParenthesesIndices = findFirstMatchingParentheses(tokens)\n        if (matchingParenthesesIndices !== null) {\n            // If there are any matching parentheses\n            const newToken = parseExprNoParens(tokens.splice(\n                matchingParenthesesIndices[0] + 1, matchingParenthesesIndices[1] - matchingParenthesesIndices[0] - 1))\n            tokens.splice(matchingParenthesesIndices[0], 2, ...newToken)\n        } else {\n            const finalToken = parseExprNoParens(tokens)\n            if (finalToken[0] instanceof Fraction) {\n                return finalToken[0]\n            } else {\n                throw new InvalidTokenError(`Invalid final token ${finalToken[0]}; not a fraction`)\n            }\n        }\n    }\n\n    throw new Error(`Expression must have at least one term`)\n}\n\nexport {\n    parseToTokens,\n    matchTokenAtBeginningOfString,\n    removeAllWhitespace,\n    findFirstMatchingParentheses,\n    parseExprNoParens,\n    parseExpression,\n}", "import Fraction from \"./fraction\";\nimport { parseExpression } from \"./expression/expression\";\n\nexport default Fraction\nexport {\n    parseExpression\n}"],
  "mappings": "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",
  "names": []
}
