import "./chunk-DFKQJ226.js";

// node_modules/ts-fraction/src/gcd.ts
function gcd(u, v) {
  if (u < 0)
    u = -u;
  if (v < 0)
    v = -v;
  let finalCoefficient = 1n;
  let uIsOdd;
  let vIsOdd;
  while (true) {
    if (u === 0n)
      return v * finalCoefficient;
    if (v === 0n)
      return u * finalCoefficient;
    uIsOdd = u % 2n === 1n;
    vIsOdd = v % 2n === 1n;
    if (!uIsOdd) {
      if (!vIsOdd) {
        finalCoefficient *= 2n;
        u /= 2n;
        v /= 2n;
      } else {
        u /= 2n;
      }
    } else {
      if (!vIsOdd) {
        v /= 2n;
      } else {
        let difference = u - v;
        if (difference < 0)
          difference = -difference;
        v = u > v ? v : u;
        u = difference;
      }
    }
  }
}
var gcd_default = gcd;

// node_modules/ts-fraction/src/utils.ts
var INTEGER_STRING_REGEX = /^[-\+]?\d+$/;
var DECIMAL_STRING_REGEX = new RegExp("^[-\\+]?((\\d*)(?=(\\.\\d+))|(\\d+)(?!(\\.\\d+)))((\\.\\d+)(?<!([-\\+]?\\d+))|((\\.\\d+)?)(?<=([-\\+]?\\d+)))$");
var DECIMAL_STRING_REGEX_BEGINNING = new RegExp("^[-\\+]?((\\d*)(?=(\\.\\d+))|(\\d+)(?!(\\.\\d+)))((\\.\\d+)(?<!([-\\+]?\\d+))|((\\.\\d+)?)(?<=([-\\+]?\\d+)))");
var DECIMAL_STRING_REGEX_NO_BEGINNING_OR_END = new RegExp(".*[-\\+]?((\\d*)(?=(\\.\\d+))|(\\d+)(?!(\\.\\d+)))((\\.\\d+)(?<!([-\\+]?\\d+))|((\\.\\d+)?)(?<=([-\\+]?\\d+))).*");
function canBeConvertedToBigInt(str) {
  return INTEGER_STRING_REGEX.test(str);
}
function canBeConvertedToFraction(str) {
  return DECIMAL_STRING_REGEX.test(str);
}

// node_modules/ts-fraction/src/fraction.ts
var Fraction = class {
  /**
   * Parses a `string`, converting it into a `Fraction` object. If the string `str` passed to this method is 
   * valid (i.e. {@linkcode canBeConvertedToFraction()} returns `true` when `str` is passed to it), then the 
   * resulting fraction will satisfy the following characteristics:
   * - If `str` represents a decimal number (i.e. {@linkcode isDecimalString()} returns `true` when `str` is 
   * passed to it), then the `bigint` value of `str` when its decimal point is removed will become the 
   * {@linkcode numerator} of the resulting `Fraction`. If the number of digits to the right of the decimal 
   * point in `str` is *n*, then the {@linkcode denominator} of the resulting `Fraction` is the `bigint` 
   * value `10^n`.
   * @param str string to convert to a `Fraction`.
   * @returns newly created `Fraction` object.
   * @throws if the string cannot be converted successfully.
   */
  static parseString(str) {
    if (!canBeConvertedToFraction(str)) {
      throw new Error("Invalid string: Cannot be converted to Fraction");
    }
    const decimalPointIndex = str.indexOf(".");
    if (decimalPointIndex === -1) {
      return new Fraction(str, 1n);
    }
    const digitsRightOfPoint = str.substring(decimalPointIndex + 1);
    const numDigitsRightOfPoint = BigInt(digitsRightOfPoint.length);
    return new Fraction(BigInt(str.replace(".", "")), BigInt(10n ** numDigitsRightOfPoint));
  }
  /**
   * Constructs a new `Fraction` object.
   * This method can construct `Fraction` objects from either of the following sets of arguments: 
   * - `a`: `Fraction` (clones the {@linkcode numerator} and {@linkcode denominator} of `a`)
   * - `a`: `number | bigint | string`, `b`: `number | bigint | string` (sets the `numerator` to 
   * the `bigint` value of `a` and the `denominator` to the `bigint` value of `b`, both obtained 
   * through calling the 
   * {@linkcode https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt/BigInt BigInt()}
   * function)
   * - No parameters, in which case `0n` is used as both the `numerator` and `denominator` of the 
   * newly constructed `Fraction` object.
   * @param {Fraction | number | bigint | string | undefined} a first parameter.
   * @param {number | bigint | string | undefined} b second parameter.
   * @throws TypeError if the parameters are not of the types specified above.
   */
  constructor(a, b) {
    if (a instanceof Fraction) {
      this.numerator = a.numerator;
      this.denominator = a.denominator;
    } else if ((typeof a === "bigint" || typeof a === "number" && Number.isInteger(a) || typeof a === "string" && canBeConvertedToBigInt(a)) && (typeof b === "bigint" || typeof b === "number" && Number.isInteger(b) || typeof b === "string" && canBeConvertedToBigInt(b))) {
      this.numerator = BigInt(a);
      this.denominator = BigInt(b);
    } else if (a === void 0 && b === void 0) {
      this.numerator = 0n;
      this.denominator = 1n;
    } else {
      const paramACorrect = typeof a === "bigint" || typeof a === "number" && Number.isInteger(a) || typeof a === "string" && canBeConvertedToBigInt(a);
      const paramBCorrect = typeof b === "bigint" || typeof b === "number" && Number.isInteger(b) || typeof b === "string" && canBeConvertedToBigInt(b);
      throw new TypeError(`Invalid parameters "${!paramACorrect ? a : ""}"${!paramBCorrect ? `, "${b}"` : ""}: Must be of type "number (integral) | bigint | string, or one Fraction parameter"`);
    }
    this.simplify();
  }
  /**
   * Adds a number of some type to this `Fraction`. The number may be expressed either as a single 
   * `number`, `bigint`, or `string` passed as the first parameter, two arguments each of type 
   * `number`, `bigint`, or `string`, or as one single `Fraction` parameter.
   * @param {Fraction | number | bigint | string} a first parameter.
   * @param {number | bigint | string | undefined} b second parameter.
   * @throws TypeError if the parameters are not of the type specified above.
   */
  plus(a, b) {
    if (a instanceof Fraction) {
      b = a.denominator;
      a = a.numerator;
    }
    if ((typeof a === "bigint" || typeof a === "number" && Number.isInteger(a) || typeof a === "string" && canBeConvertedToBigInt(a)) && (typeof b === "bigint" || typeof b === "number" && Number.isInteger(b) || typeof b === "string" && canBeConvertedToBigInt(b) || b === void 0)) {
      a = BigInt(a);
      if (b !== void 0) {
        b = BigInt(b);
      } else {
        b = 1n;
      }
      let newNumerator = this.numerator * b + a * this.denominator;
      let newDenominator = this.denominator * b;
      let commonFactor = gcd_default(newNumerator, newDenominator);
      return new Fraction(newNumerator / commonFactor, newDenominator / commonFactor).simplify();
    } else {
      const paramACorrect = typeof a === "bigint" || typeof a === "number" && Number.isInteger(a) || typeof a === "string" && canBeConvertedToBigInt(a);
      const paramBCorrect = typeof b === "bigint" || typeof b === "number" && Number.isInteger(b) || typeof b === "string" && canBeConvertedToBigInt(b) || b === void 0;
      throw new TypeError(`Invalid parameters "${!paramACorrect ? a : ""}"${!paramBCorrect ? `, "${b}"` : ""}: Must be of type "number | bigint | string, or one Fraction parameter"`);
    }
  }
  /**
   * Subtracts a number of some type from this `Fraction`. The number may be expressed either as a single 
   * `number`, `bigint`, or `string` passed as the first parameter, two arguments each of type 
   * `number`, `bigint`, or `string`, or as one single `Fraction` parameter.
   * @param {Fraction | number | bigint | string} a first parameter.
   * @param {number | bigint | string | undefined} b second parameter.
   * @throws TypeError if the parameters are not of the type specified above.
   */
  minus(a, b) {
    if (a instanceof Fraction) {
      b = a.denominator;
      a = a.numerator;
    }
    if ((typeof a === "bigint" || typeof a === "number" && Number.isInteger(a) || typeof a === "string" && canBeConvertedToBigInt(a)) && (typeof b === "bigint" || typeof b === "number" && Number.isInteger(b) || typeof b === "string" && canBeConvertedToBigInt(b) || b === void 0)) {
      a = BigInt(a);
      if (b !== void 0) {
        b = BigInt(b);
      } else {
        b = 1n;
      }
      let newNumerator = this.numerator * b - a * this.denominator;
      let newDenominator = this.denominator * b;
      let commonFactor = gcd_default(newNumerator, newDenominator);
      return new Fraction(newNumerator / commonFactor, newDenominator / commonFactor).simplify();
    } else {
      const paramACorrect = typeof a === "bigint" || typeof a === "number" && Number.isInteger(a) || typeof a === "string" && canBeConvertedToBigInt(a);
      const paramBCorrect = typeof b === "bigint" || typeof b === "number" && Number.isInteger(b) || typeof b === "string" && canBeConvertedToBigInt(b) || b === void 0;
      throw new TypeError(`Invalid parameters "${!paramACorrect ? a : ""}"${!paramBCorrect ? `, "${b}"` : ""}: Must be of type "number | bigint | string, or one Fraction parameter"`);
    }
  }
  /**
   * Multiplies this `Fraction` by a number of some type. The number may be expressed either as a single 
   * `number`, `bigint`, or `string` passed as the first parameter, two arguments each of type 
   * `number`, `bigint`, or `string`, or as one single `Fraction` parameter.
   * @param {Fraction | number | bigint | string} a first parameter.
   * @param {number | bigint | string | undefined} b second parameter.
   * @throws TypeError if the parameters are not of the type specified above.
   */
  times(a, b) {
    if (a instanceof Fraction) {
      b = a.denominator;
      a = a.numerator;
    }
    if ((typeof a === "bigint" || typeof a === "number" && Number.isInteger(a) || typeof a === "string" && canBeConvertedToBigInt(a)) && (typeof b === "bigint" || typeof b === "number" && Number.isInteger(b) || typeof b === "string" && canBeConvertedToBigInt(b) || b === void 0)) {
      a = BigInt(a);
      if (b !== void 0) {
        b = BigInt(b);
      } else {
        b = 1n;
      }
      let newNumerator = this.numerator * a;
      let newDenominator = this.denominator * b;
      let commonFactor = gcd_default(newNumerator, newDenominator);
      return new Fraction(newNumerator / commonFactor, newDenominator / commonFactor).simplify();
    } else {
      const paramACorrect = typeof a === "bigint" || typeof a === "number" && Number.isInteger(a) || typeof a === "string" && canBeConvertedToBigInt(a);
      const paramBCorrect = typeof b === "bigint" || typeof b === "number" && Number.isInteger(b) || typeof b === "string" && canBeConvertedToBigInt(b) || b === void 0;
      throw new TypeError(`Invalid parameters "${!paramACorrect ? a : ""}"${!paramBCorrect ? `, "${b}"` : ""}: Must be of type "number | bigint | string, or one Fraction parameter"`);
    }
  }
  /**
   * Divides this `Fraction` by a number of some type. The number may be expressed either as a single 
   * `number`, `bigint`, or `string` passed as the first parameter, two arguments each of type 
   * `number`, `bigint`, or `string`, or as one single `Fraction` parameter.
   * @param {Fraction | number | bigint | string} a first parameter.
   * @param {number | bigint | string | undefined} b second parameter.
   * @throws TypeError if the parameters are not of the type specified above.
   */
  div(a, b) {
    if (a instanceof Fraction) {
      b = a.denominator;
      a = a.numerator;
    }
    if ((typeof a === "bigint" || typeof a === "number" && Number.isInteger(a) || typeof a === "string" && canBeConvertedToBigInt(a)) && (typeof b === "bigint" || typeof b === "number" && Number.isInteger(b) || typeof b === "string" && canBeConvertedToBigInt(b) || b === void 0)) {
      a = BigInt(a);
      if (b !== void 0) {
        b = BigInt(b);
      } else {
        b = 1n;
      }
      let newNumerator = this.numerator * b;
      let newDenominator = this.denominator * a;
      let commonFactor = gcd_default(newNumerator, newDenominator);
      return new Fraction(newNumerator / commonFactor, newDenominator / commonFactor).simplify();
    } else {
      const paramACorrect = typeof a === "bigint" || typeof a === "number" && Number.isInteger(a) || typeof a === "string" && canBeConvertedToBigInt(a);
      const paramBCorrect = typeof b === "bigint" || typeof b === "number" && Number.isInteger(b) || typeof b === "string" && canBeConvertedToBigInt(b) || b === void 0;
      throw new TypeError(`Invalid parameters "${!paramACorrect ? a : ""}"${!paramBCorrect ? `, "${b}"` : ""}: Must be of type "number | bigint | string, or one Fraction parameter"`);
    }
  }
  /**
   * Tests this `Fraction` for equality with a number of some type. The number may be expressed either as a single 
   * `number`, `bigint`, or `string` passed as the first parameter, two arguments each of type 
   * `number`, `bigint`, or `string`, or as one single `Fraction` parameter.
   * @param {Fraction | number | bigint | string} a first parameter.
   * @param {number | bigint | string | undefined} b second parameter.
   * @throws TypeError if the parameters are not of the type specified above.
   */
  equals(a, b) {
    if (a instanceof Fraction) {
      b = a.denominator;
      a = a.numerator;
    }
    if ((typeof a === "bigint" || typeof a === "number" && Number.isInteger(a) || typeof a === "string" && canBeConvertedToBigInt(a)) && (typeof b === "bigint" || typeof b === "number" && Number.isInteger(b) || typeof b === "string" && canBeConvertedToBigInt(b) || b === void 0)) {
      a = BigInt(a);
      if (b !== void 0) {
        b = BigInt(b);
      } else {
        b = 1n;
      }
      return this.numerator === a && this.denominator === b;
    } else {
      const paramACorrect = typeof a === "bigint" || typeof a === "number" && Number.isInteger(a) || typeof a === "string" && canBeConvertedToBigInt(a);
      const paramBCorrect = typeof b === "bigint" || typeof b === "number" && Number.isInteger(b) || typeof b === "string" && canBeConvertedToBigInt(b) || b === void 0;
      throw new TypeError(`Invalid parameters "${!paramACorrect ? a : ""}"${!paramBCorrect ? `, "${b}"` : ""}: Must be of type "number | bigint | string, or one Fraction parameter"`);
    }
  }
  /**
   * Simplifies this `Fraction` by dividing by the common factor of the `numerator` and `denominator`.
   */
  simplify() {
    const commonFactor = gcd_default(this.numerator, this.denominator);
    this.numerator /= commonFactor;
    this.denominator /= commonFactor;
    return this;
  }
  /**
   * Returns a decimal `string` representation of this `Fraction`, accurate to a certain number of 
   * decimal places.
   * @param numDecimalPlaces number of decimal places of accuracy to generate for the fraction's 
   * decimal representation.
   * @returns decimal representation of this `Fraction`.
   */
  toDecimal(numDecimalPlaces) {
    let strNumerator = this.numerator.toString();
    let strDenominator = this.denominator.toString();
    let absDen = 0n;
    const negative = strNumerator.startsWith("-") !== strDenominator.startsWith("-");
    if (strNumerator.startsWith("-")) {
      strNumerator = strNumerator.substring(1);
    }
    if (strDenominator.startsWith("-")) {
      strDenominator = strDenominator.substring(1);
      absDen = -this.denominator;
    } else {
      absDen = this.denominator;
    }
    let decimal = "";
    let dividend;
    let quotient = 0n;
    let remainder = 0n;
    for (let i = 0; i < strNumerator.length; i++) {
      dividend = remainder * 10n + BigInt(strNumerator.substring(i, i + 1));
      quotient = dividend / absDen;
      remainder = dividend % absDen;
      decimal += quotient;
    }
    if (numDecimalPlaces > 0n) {
      decimal += ".";
      for (let i = 0; i < numDecimalPlaces + 1n; i++) {
        dividend = remainder * 10n;
        quotient = dividend / absDen;
        remainder = dividend % absDen;
        decimal += quotient;
      }
      if (BigInt(decimal.substring(decimal.length - 1, decimal.length)) >= 5n) {
        decimal = decimal.substring(0, decimal.length - 2) + (BigInt(decimal[decimal.length - 2]) + 1n).toString();
      } else {
        decimal = decimal.substring(0, decimal.length - 1);
      }
    }
    decimal = decimal.replace(/^0*(?!\.)/, "");
    if (/\.0+$/.test(decimal)) {
      decimal = decimal.replace(/\.0+$/, "");
    }
    if (negative) {
      decimal = `-${decimal}`;
    }
    return decimal;
  }
};
var fraction_default = Fraction;

// node_modules/ts-fraction/src/expression/tokentype.ts
var TokenType = Object.freeze({
  AdditionOperator: Object.freeze({
    startingRegex: /^\+/
  }),
  SubtractionOperator: Object.freeze({
    startingRegex: /^-/
  }),
  MultiplicationOperator: Object.freeze({
    startingRegex: /^\*/
  }),
  DivisionOperator: Object.freeze({
    startingRegex: /^\//
  }),
  LeftParenthesisOperator: Object.freeze({
    startingRegex: /^\(/
  }),
  RightParenthesisOperator: Object.freeze({
    startingRegex: /^\)/
  }),
  Number: Object.freeze({
    startingRegex: DECIMAL_STRING_REGEX_BEGINNING
  })
});
var tokentype_default = TokenType;

// node_modules/ts-fraction/src/expression/invalid_token_error.ts
var InvalidTokenError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidTokenError";
  }
};

// node_modules/ts-fraction/src/expression/unmatched_parenthesis_error.ts
var UnmatchedParenthesisError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "UnmatchedParenthesisError";
  }
};

// node_modules/ts-fraction/src/expression/evaluation_error.ts
var EvaluationError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "EvaluationError";
  }
};

// node_modules/ts-fraction/src/expression/expression.ts
function matchTokenAtBeginningOfString(str) {
  for (const token of Object.values(tokentype_default)) {
    if (token.startingRegex.test(str)) {
      if (token === tokentype_default.Number) {
        const matchedStringArray = str.match(token.startingRegex);
        try {
          return [
            token,
            str.replace(token.startingRegex, ""),
            fraction_default.parseString(matchedStringArray[0])
          ];
        } catch (err) {
          if (err instanceof Error && err.message === "Invalid string: Cannot be converted to Fraction") {
            throw new InvalidTokenError(`Invalid number ${matchedStringArray[0]} cannot be converted to Fraction`);
          }
        }
      }
      return [token, str.replace(token.startingRegex, "")];
    }
  }
  return null;
}
function parseToTokens(str) {
  let tokens = [];
  str = removeAllWhitespace(str);
  while (str.length > 0) {
    const token = matchTokenAtBeginningOfString(str);
    if (token !== null) {
      if (token[2] !== void 0) {
        tokens.push(token[2]);
      } else {
        tokens.push(token[0]);
      }
      str = token[1];
    } else {
      throw new InvalidTokenError(`Invalid token at: ${str}`);
    }
  }
  return tokens;
}
function removeAllWhitespace(str) {
  return str.replace(/\s*/g, "");
}
function findFirstMatchingParentheses(expr) {
  let leftIndex = -1;
  for (let i = 0; i < expr.length; i++) {
    if (expr[i] === tokentype_default.LeftParenthesisOperator) {
      leftIndex = i;
    } else if (expr[i] === tokentype_default.RightParenthesisOperator) {
      if (leftIndex === -1) {
        throw new UnmatchedParenthesisError("Unmatched )");
      }
      return [leftIndex, i];
    }
  }
  if (leftIndex !== -1) {
    throw new UnmatchedParenthesisError("Unmatched (");
  }
  return null;
}
function parseExprNoParens(expr) {
  while (expr.includes(tokentype_default.MultiplicationOperator) || expr.includes(tokentype_default.DivisionOperator)) {
    const index = expr.findIndex(
      (elem) => elem === tokentype_default.MultiplicationOperator || elem === tokentype_default.DivisionOperator
    );
    if (index - 1 < 0) {
      throw new EvaluationError(`${expr[index] === tokentype_default.MultiplicationOperator ? "Multiplication" : "Division"} operator at index ${index} has no left operand`);
    }
    if (index + 1 >= expr.length) {
      throw new EvaluationError(`${expr[index] === tokentype_default.MultiplicationOperator ? "Multiplication" : "Division"} operator at index ${index} has no right operand`);
    }
    if (expr[index - 1] instanceof fraction_default && expr[index + 1] instanceof fraction_default) {
      expr[index - 1] = expr[index - 1];
      if (expr[index] === tokentype_default.MultiplicationOperator) {
        expr.splice(index - 1, 3, expr[index - 1].times(expr[index + 1]));
      } else {
        expr.splice(index - 1, 3, expr[index - 1].div(expr[index + 1]));
      }
    } else {
      throw new EvaluationError(`${!(expr[index - 1] instanceof fraction_default) ? `${expr[index] === tokentype_default.MultiplicationOperator ? `Multiplication` : `Division`} operator at index ${index - 1}` : ""} ${!(expr[index - 1] instanceof fraction_default) && !(expr[index + 1] instanceof fraction_default) ? `and ` : ""}${!(expr[index + 1] instanceof fraction_default) ? `${expr[index] === tokentype_default.MultiplicationOperator ? `Multiplication` : `Division`} operator at index ${index + 1} ` : ""}has no ${!(expr[index - 1] instanceof fraction_default) ? "left" : ""} ${!(expr[index - 1] instanceof fraction_default) && !(expr[index + 1] instanceof fraction_default) ? `or ` : ""}${!(expr[index + 1] instanceof fraction_default) ? "right " : ""}operand`);
    }
  }
  while (expr.includes(tokentype_default.AdditionOperator) || expr.includes(tokentype_default.SubtractionOperator)) {
    const index = expr.findIndex(
      (elem) => elem === tokentype_default.AdditionOperator || elem === tokentype_default.SubtractionOperator
    );
    if (index - 1 < 0) {
      throw new EvaluationError(`${expr[index] === tokentype_default.AdditionOperator ? "Addition" : "Subtraction"} operator at index ${index} has no left operand`);
    }
    if (index + 1 >= expr.length) {
      throw new EvaluationError(`${expr[index] === tokentype_default.AdditionOperator ? "Addition" : "Subtraction"} operator at index ${index} has no right operand`);
    }
    if (expr[index - 1] instanceof fraction_default && expr[index + 1] instanceof fraction_default) {
      expr[index - 1] = expr[index - 1];
      if (expr[index] === tokentype_default.AdditionOperator) {
        expr.splice(index - 1, 3, expr[index - 1].plus(expr[index + 1]));
      } else {
        expr.splice(index - 1, 3, expr[index - 1].minus(expr[index + 1]));
      }
    } else {
      throw new EvaluationError(`${!(expr[index - 1] instanceof fraction_default) ? `${expr[index] === tokentype_default.AdditionOperator ? `Addition` : `Subtraction`} operator at index ${index - 1}` : ""} ${!(expr[index - 1] instanceof fraction_default) && !(expr[index + 1] instanceof fraction_default) ? `and ` : ""}${!(expr[index + 1] instanceof fraction_default) ? `${expr[index] === tokentype_default.AdditionOperator ? `Addition` : `Subtraction`} operator at index ${index + 1} ` : ""}has no ${!(expr[index - 1] instanceof fraction_default) ? "left" : ""} ${!(expr[index - 1] instanceof fraction_default) && !(expr[index + 1] instanceof fraction_default) ? `or ` : ""}${!(expr[index + 1] instanceof fraction_default) ? "right " : ""}operand`);
    }
  }
  return expr;
}
function parseExpression(expr) {
  let tokens = parseToTokens(expr);
  while (tokens.length >= 1) {
    const matchingParenthesesIndices = findFirstMatchingParentheses(tokens);
    if (matchingParenthesesIndices !== null) {
      const newToken = parseExprNoParens(tokens.splice(
        matchingParenthesesIndices[0] + 1,
        matchingParenthesesIndices[1] - matchingParenthesesIndices[0] - 1
      ));
      tokens.splice(matchingParenthesesIndices[0], 2, ...newToken);
    } else {
      const finalToken = parseExprNoParens(tokens);
      if (finalToken[0] instanceof fraction_default) {
        return finalToken[0];
      } else {
        throw new InvalidTokenError(`Invalid final token ${finalToken[0]}; not a fraction`);
      }
    }
  }
  throw new Error(`Expression must have at least one term`);
}

// node_modules/ts-fraction/src/index.ts
var src_default = fraction_default;
export {
  src_default as default,
  parseExpression
};
//# sourceMappingURL=ts-fraction.js.map
